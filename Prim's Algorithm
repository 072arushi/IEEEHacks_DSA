#include <iostream>
#include <climits>
using namespace std;

int findMinVertex(int *weights, bool *visited, int n)
{
   int minVertex = -1;                  // Initializing min vertex to -1 
  for (int i = 0; i < n; i++)
  {
     /*Conditions : the vertex must be unvisited and either minVertex value is -1
     or if minVertex has some vertex to it, then weight of currentvertex
     should be less than the weight of the minVertex.*/
     
    if (!visited[i] && (minVertex == -1 || weights[i] < weights[minVertex])) 
    {
    minVertex = i;                        // assigning min vertex
    }
  }
 return minVertex;
}

void prims(int **edges, int nodes)
{
    //one parent array, one weighted array and one visited array is needed 
    int *parent = new int[nodes];  
    int *weights = new int[nodes];
    bool *visited = new bool[nodes];

    for(int i = 0; i < nodes; i++)
    {
      visited[i] = false;                  //initially visited node array is set to false
      weights[i] = INT_MAX;                // And weights are set to infinity
    }
    
    // Values assigned to vertex 0.(the selected starting vertex to begin with)
    parent[0] = -1; 
    weights[0] = 0;

    for (int i = 0; i < nodes-1; i++) 
    {
         int minVertex = findMinVertex(weights, visited, nodes);           // finding min vertex
         visited[minVertex] = true;                        // marking the min vertex as visited

         // Explore unvisited neighbors
       for (int j = 0; j < nodes; j++) 
       {
          if(edges[minVertex][j] != 0 && !visited[j])
          {
              // decide whether to update or not
            if(edges[minVertex][j] < weights[j])
            {
              weights[j] = edges[minVertex][j];           // update the weighted array
              parent[j] = minVertex;                      // update the parent array
            }
          }
       }
    }
    
    // printing the final MST path
    for (int i = 0; i < nodes; i++) 
    {
       if (parent[i] < i) 
       {
         cout << parent[i] << " " << i << " " <<weights[i] << endl;
       }
       else
       {
         cout << i << " " << parent[i] << " " << weights[i] << endl;
       }
    }
}


int main()
{
    int nodes;
    int e;                                  // e--> no of vertices
    cout << "enter nodes and vertices";
    cin >> nodes >> e;
    int **edges = new int*[nodes];           // Adjacency matrix used to store the graph
    for (int i = 0; i < nodes; i++) 
    {
      edges[i] = new int[nodes];
      for (int j = 0; j < nodes; j++) 
      {
        edges[i][j] = 0;                      /* Initially all pairs are assigned weight = 0 which
                                              means that there is no edge between them*/
      }
    }
    for (int i = 0; i < e; i++)
    {
      int st, ed, weight;                      // st --> start  ed --> end
      cin >> st >> ed >> weight; 
      edges[st][ed] = weight;
      edges[ed][st] = weight;
    }
    prims(edges, nodes);
    for(int i = 0; i < nodes; i++)
    {
      delete [] edges[i]; 
    }
    delete [] edges;
    return 0;
}









PRIM'S ALGORITHM
  This algorithm is used to find MST for a given undirected-weighted graph. 

step 1 : Taking three array and initializing them:

         int *parent = new int[nodes];  
         int *weights = new int[nodes];
         bool *visited = new bool[nodes];

         for(int i = 0; i < nodes; i++)
    {
      visited[i] = false; //initially visited node array is set to false
      weights[i] = INT_MAX;// And weights are set to infinity
    }
    // Values assigned to vertex 0.(the selected starting vertex to begin with)
    parent[0] = -1; 
    weights[0] = 0;


step 2 : Finding minimum vertex and updating the parent and weight array. Also once vertex = minimum vertex, we mark them visited:

          for (int i = 0; i < nodes-1; i++) 
     {
         int minVertex = findMinVertex(weights, visited, nodes); // finding min vertex
         visited[minVertex] = true; // marking the min vertex as visited

         // Explore unvisited neighbors
       for (int j = 0; j < nodes; j++) 
       {
          if(edges[minVertex][j] != 0 && !visited[j])
          {
              // decide whether to update or not
            if(edges[minVertex][j] < weights[j])
            {
              weights[j] = edges[minVertex][j]; // update the weighted array
              parent[j] = minVertex; // update the parent array
            }
          }
       }
     }



step 3 :  Declaring a funtion for finding minVertex :
          int findMinVertex(int *weights, bool *visited, int n)
    {
       int minVertex = -1; // Initializing min vertex to -1 
     for (int i = 0; i < n; i++)
    {
     /*Conditions : the vertex must be unvisited and either minVertex value is -1
     or if minVertex has some vertex to it, then weight of currentvertex
     should be less than the weight of the minVertex.*/
      if (!visited[i] && (minVertex == -1 || weights[i] < weights[minVertex])) 
      {
      minVertex = i; // assigning min vertex
      }
    }
    return minVertex;
   }


step 4 :   printing the final MST
           for (int i = 0; i < nodes; i++) 
    {
       if (parent[i] < i) 
       {
         cout << parent[i] << " " << i << " " <<weights[i] << endl;
       }
       else
       {
         cout << i << " " << parent[i] << " " << weights[i] << endl;
       }
    }


For better understanding the procedure step by step through visually(graphs) you can go to link below:
   https://drive.google.com/file/d/1cXLHaNzXstqfhkpqdP0vMAr2pZurNvSu/view?usp=drivesdk


  PSEUDO CODE
  // U--> contains the list of vertices
  // e--> no of 
  T = ∅;
  U = { 1 };
while (U ≠ e)
    let (u, e) be the lowest cost edge such that u ∈ U and v ∈ e - U;
    T = T ∪ {(u, e)}
    U = U ∪ {e}



  Sample Input :
4 4
0 1 3
0 3 5
1 2 1
2 3 8

Sample Output:
0 1 3
1 2 1
0 3 5


TIME COMPLEXITY:
 1.The time complexity for finding the minimum weighted vertex is O(n) for each iteration. So for (n-1) edges, it becomes O(n2).
 2.For exploring the neighbor vertices, the time taken is O(n2).
